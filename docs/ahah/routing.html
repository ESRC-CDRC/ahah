<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ahah.routing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ahah.routing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import cudf
import cugraph
import cuspatial
import dask.dataframe as dd
import numpy as np
import pandas as pd
import time
import warnings
from ahah.common.logger import logger
from ahah.common.utils import Config
from rich.progress import track


class Routing:
    &#34;&#34;&#34;
    Main class for calculating routing from POI to postcodes within a road network.

    Primarily uses `cugraph` to GPU accelerate routing. While the interest is distance
    from postcodes to POI, this class does routing from POI to postcodes, appending to
    a large intermediate file. When complete the routing takes the minimum distance
    for each postcode.

    Parameters
    ----------
    name : str
        Name of POI
    edges : cudf.DataFrame
        Dataframe containing road edges
    nodes : cudf.DataFrame
        Dataframe containing road nodes
    postcodes : cudf.DataFrame
        Dataframe containing all postcodes
    pois : pd.DataFrame
        Dataframe containing all POIs
    weights : str
        Graph weights to use, e.g. `time_weighted` or `distance`
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        edges: cudf.DataFrame,
        nodes: cudf.DataFrame,
        postcodes: cudf.DataFrame,
        pois: pd.DataFrame,
        weights: str = &#34;time_weighted&#34;,
        use_buffers: bool = True,
    ):
        self.postcode_ids: np.ndarray = postcodes[&#34;node_id&#34;].unique().to_array()
        self.pois = pois.drop_duplicates(&#34;node_id&#34;)

        self.edges = edges
        self.nodes = nodes

        self.name = name
        self.weights = weights
        self.use_buffers = use_buffers

        if not self.use_buffers:
            self.graph = cugraph.Graph()
            self.graph.from_cudf_edgelist(
                self.edges,
                source=&#34;source&#34;,
                destination=&#34;target&#34;,
                edge_attr=self.weights,
            )

        self.log_file = Config.OUT_DATA / &#34;logs&#34; / f&#34;{self.name}_intermediate.h5&#34;

        if self.log_file.exists():
            logger.warning(&#34;Resuming from a previous run.&#34;)
            with warnings.catch_warnings():
                warnings.filterwarnings(&#34;ignore&#34;, category=UserWarning)
                # -1 in case program stopped while saving to hdf
                self.idx = (
                    dd.read_hdf(self.log_file, key=self.name)[&#34;idx&#34;].max().compute() - 1
                )
                logger.warning(
                    f&#34;Run resumed at {self.idx / len(self.pois) * 100:.2f}% ({self.idx} / {len(self.pois)})&#34;
                )
        else:
            self.idx = 0

    def fit(self) -&gt; None:
        &#34;&#34;&#34;
        Iterate and apply routing to each POI

        This function primarily allows for the intermediate steps in routing to be
        logged. This means that if the routing is stopped midway it can be restarted.
        &#34;&#34;&#34;
        t1 = time.time()
        for poi in track(
            self.pois.iloc[self.idx :].itertuples(),
            description=f&#34;Processing {self.name}...&#34;,
            total=len(self.pois) - self.idx,
        ):
            self.get_shortest_dists(poi)
        t2 = time.time()
        tdiff = t2 - t1
        logger.debug(
            f&#34;Routing complete for {self.name} in {tdiff / 60:.2f} minutes,&#34;
            &#34; finding minimum distances.&#34;
        )

        t1 = time.time()
        self.distances = (
            dd.read_hdf(
                self.log_file,
                key=f&#34;{self.name}&#34;,
                columns=[&#34;vertex&#34;, &#34;distance&#34;],
            )
            .map_partitions(cudf.from_pandas)
            .groupby(&#34;vertex&#34;)
            .min()
            .compute()
        )
        t2 = time.time()
        tdiff = t2 - t1
        logger.debug(
            f&#34;Found minimum distances for {self.name} in {tdiff / 60:.2f} minutes.&#34;
        )
        self.log_file.unlink()

    def create_sub_graph(self, poi) -&gt; cugraph.Graph:
        &#34;&#34;&#34;
        Create a subgraph of road nodes based on buffer distance

        The subgraph is created using euclidean distance and
        `cuspatial.points_in_spatial_window`. If buffers are not large enough to
        include all nodes identified as important to that particular POI, it is
        increased in size.

        Parameters
        ----------
        poi : namedtuple
            Single POI created by `df.itertuples()`

        Returns
        -------
        cugraph.Graph:
            Graph object that is a subset of all road nodes
        &#34;&#34;&#34;
        # very small buffers do not work well
        buffer = poi.buffer if poi.buffer &gt;= 1000 else 1000
        while True:
            node_subset = cuspatial.points_in_spatial_window(
                min_x=poi.easting - buffer,
                max_x=poi.easting + buffer,
                min_y=poi.northing - buffer,
                max_y=poi.northing + buffer,
                xs=self.nodes[&#34;easting&#34;],
                ys=self.nodes[&#34;northing&#34;],
            )
            node_subset = node_subset.merge(
                self.nodes, left_on=[&#34;x&#34;, &#34;y&#34;], right_on=[&#34;easting&#34;, &#34;northing&#34;]
            ).drop([&#34;x&#34;, &#34;y&#34;], axis=1)
            sub_source = self.edges.merge(
                node_subset, left_on=&#34;source&#34;, right_on=&#34;node_id&#34;
            )
            sub_target = self.edges.merge(
                node_subset, left_on=&#34;target&#34;, right_on=&#34;node_id&#34;
            )
            sub_edges = sub_source.append(sub_target).drop_duplicates(
                [&#34;source&#34;, &#34;target&#34;]
            )
            sub_graph = cugraph.Graph()
            sub_graph.from_cudf_edgelist(
                sub_edges,
                source=&#34;source&#34;,
                destination=&#34;target&#34;,
                edge_attr=self.weights,
            )

            pc_nodes = cudf.Series(poi.pc_node).isin(sub_graph.nodes()).sum()
            poi_node = sub_graph.nodes().isin([poi.node_id]).sum()

            # ensure all postcode nodes in + poi node
            if (poi_node) &amp; (pc_nodes == len(poi.pc_node)):
                return sub_graph
            buffer = (buffer + 100) * 2
            logger.debug(f&#34;{poi.Index=}: increasing {buffer=}&#34;)

    def get_shortest_dists(self, poi):
        &#34;&#34;&#34;
        Use `cugraph.sssp` to calculate shortest paths from POI to postcodes

        First subsets road graph, then finds shortest paths, ensuring all paths are
        routed that are known to be important to each POI. Saves to `hdf` to allow
        restarts.

        Parameters
        ----------
        poi : namedtuple
            Single POI created from `df.itertuples()`
        &#34;&#34;&#34;
        if self.use_buffers:
            self.graph = self.create_sub_graph(poi=poi)

        shortest_paths: cudf.DataFrame = cugraph.filter_unreachable(
            cugraph.sssp(self.graph, source=poi.node_id)
        )
        pc_dist = shortest_paths[shortest_paths.vertex.isin(self.postcode_ids)]

        self.idx += 1
        pc_dist[&#34;idx&#34;] = self.idx
        pc_dist.to_hdf(
            self.log_file,
            key=self.name,
            format=&#34;table&#34;,
            append=True,
            index=False,
        )


if __name__ == &#34;__main__&#34;:
    logger.info(&#34;Starting Routing!&#34;)
    logger.debug(&#34;Reading graph and postcodes.&#34;)

    edges = cudf.read_parquet(Config.OS_GRAPH / &#34;edges.parquet&#34;)

    nodes = cudf.read_parquet(Config.OS_GRAPH / &#34;nodes.parquet&#34;)

    # edges = cudf.read_hdf(Config.OS_GRAPH / &#34;edges.h5&#34;, &#34;table&#34;)
    # nodes = cudf.read_hdf(Config.OS_GRAPH / &#34;nodes.h5&#34;, &#34;table&#34;)
    postcodes = cudf.read_parquet(Config.PROCESSED_DATA / &#34;postcodes.parquet&#34;)

    logger.debug(&#34;Finished reading nodes, edges and postcodes.&#34;)

    logger.debug(f&#34;Starting Routing for {Config.POI_LIST}.&#34;)
    for idx, poi in enumerate(Config.POI_LIST):
        logger.debug(f&#34;Starting routing for {poi} ({idx+1}/{len(Config.POI_LIST)}).&#34;)
        OUT_FILE = Config.OUT_DATA / f&#34;distances_{poi}.csv&#34;

        if not OUT_FILE.exists():
            df = pd.read_parquet(Config.PROCESSED_DATA / f&#34;{poi}.parquet&#34;)

            routing = Routing(
                name=poi,
                edges=edges,
                nodes=nodes,
                postcodes=postcodes,
                pois=df,
                use_buffers=True,
                weights=&#34;length&#34;,
            )
            routing.fit()

            distances = routing.distances.join(
                postcodes.set_index(&#34;node_id&#34;)
            ).reset_index()

            logger.debug(f&#34;Saving distances for {poi} to {OUT_FILE}.&#34;)
            distances[[&#34;postcode&#34;, &#34;distance&#34;]].to_csv(OUT_FILE, index=False)
        else:
            logger.warning(f&#34;{OUT_FILE} exists! Skipping {poi}.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ahah.routing.Routing"><code class="flex name class">
<span>class <span class="ident">Routing</span></span>
<span>(</span><span>name: str, edges: cudf.DataFrame, nodes: cudf.DataFrame, postcodes: cudf.DataFrame, pois: pd.DataFrame, weights: str = 'time_weighted', use_buffers: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class for calculating routing from POI to postcodes within a road network.</p>
<p>Primarily uses <code>cugraph</code> to GPU accelerate routing. While the interest is distance
from postcodes to POI, this class does routing from POI to postcodes, appending to
a large intermediate file. When complete the routing takes the minimum distance
for each postcode.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of POI</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>cudf.DataFrame</code></dt>
<dd>Dataframe containing road edges</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>cudf.DataFrame</code></dt>
<dd>Dataframe containing road nodes</dd>
<dt><strong><code>postcodes</code></strong> :&ensp;<code>cudf.DataFrame</code></dt>
<dd>Dataframe containing all postcodes</dd>
<dt><strong><code>pois</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe containing all POIs</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>str</code></dt>
<dd>Graph weights to use, e.g. <code>time_weighted</code> or <code>distance</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Routing:
    &#34;&#34;&#34;
    Main class for calculating routing from POI to postcodes within a road network.

    Primarily uses `cugraph` to GPU accelerate routing. While the interest is distance
    from postcodes to POI, this class does routing from POI to postcodes, appending to
    a large intermediate file. When complete the routing takes the minimum distance
    for each postcode.

    Parameters
    ----------
    name : str
        Name of POI
    edges : cudf.DataFrame
        Dataframe containing road edges
    nodes : cudf.DataFrame
        Dataframe containing road nodes
    postcodes : cudf.DataFrame
        Dataframe containing all postcodes
    pois : pd.DataFrame
        Dataframe containing all POIs
    weights : str
        Graph weights to use, e.g. `time_weighted` or `distance`
    &#34;&#34;&#34;

    def __init__(
        self,
        name: str,
        edges: cudf.DataFrame,
        nodes: cudf.DataFrame,
        postcodes: cudf.DataFrame,
        pois: pd.DataFrame,
        weights: str = &#34;time_weighted&#34;,
        use_buffers: bool = True,
    ):
        self.postcode_ids: np.ndarray = postcodes[&#34;node_id&#34;].unique().to_array()
        self.pois = pois.drop_duplicates(&#34;node_id&#34;)

        self.edges = edges
        self.nodes = nodes

        self.name = name
        self.weights = weights
        self.use_buffers = use_buffers

        if not self.use_buffers:
            self.graph = cugraph.Graph()
            self.graph.from_cudf_edgelist(
                self.edges,
                source=&#34;source&#34;,
                destination=&#34;target&#34;,
                edge_attr=self.weights,
            )

        self.log_file = Config.OUT_DATA / &#34;logs&#34; / f&#34;{self.name}_intermediate.h5&#34;

        if self.log_file.exists():
            logger.warning(&#34;Resuming from a previous run.&#34;)
            with warnings.catch_warnings():
                warnings.filterwarnings(&#34;ignore&#34;, category=UserWarning)
                # -1 in case program stopped while saving to hdf
                self.idx = (
                    dd.read_hdf(self.log_file, key=self.name)[&#34;idx&#34;].max().compute() - 1
                )
                logger.warning(
                    f&#34;Run resumed at {self.idx / len(self.pois) * 100:.2f}% ({self.idx} / {len(self.pois)})&#34;
                )
        else:
            self.idx = 0

    def fit(self) -&gt; None:
        &#34;&#34;&#34;
        Iterate and apply routing to each POI

        This function primarily allows for the intermediate steps in routing to be
        logged. This means that if the routing is stopped midway it can be restarted.
        &#34;&#34;&#34;
        t1 = time.time()
        for poi in track(
            self.pois.iloc[self.idx :].itertuples(),
            description=f&#34;Processing {self.name}...&#34;,
            total=len(self.pois) - self.idx,
        ):
            self.get_shortest_dists(poi)
        t2 = time.time()
        tdiff = t2 - t1
        logger.debug(
            f&#34;Routing complete for {self.name} in {tdiff / 60:.2f} minutes,&#34;
            &#34; finding minimum distances.&#34;
        )

        t1 = time.time()
        self.distances = (
            dd.read_hdf(
                self.log_file,
                key=f&#34;{self.name}&#34;,
                columns=[&#34;vertex&#34;, &#34;distance&#34;],
            )
            .map_partitions(cudf.from_pandas)
            .groupby(&#34;vertex&#34;)
            .min()
            .compute()
        )
        t2 = time.time()
        tdiff = t2 - t1
        logger.debug(
            f&#34;Found minimum distances for {self.name} in {tdiff / 60:.2f} minutes.&#34;
        )
        self.log_file.unlink()

    def create_sub_graph(self, poi) -&gt; cugraph.Graph:
        &#34;&#34;&#34;
        Create a subgraph of road nodes based on buffer distance

        The subgraph is created using euclidean distance and
        `cuspatial.points_in_spatial_window`. If buffers are not large enough to
        include all nodes identified as important to that particular POI, it is
        increased in size.

        Parameters
        ----------
        poi : namedtuple
            Single POI created by `df.itertuples()`

        Returns
        -------
        cugraph.Graph:
            Graph object that is a subset of all road nodes
        &#34;&#34;&#34;
        # very small buffers do not work well
        buffer = poi.buffer if poi.buffer &gt;= 1000 else 1000
        while True:
            node_subset = cuspatial.points_in_spatial_window(
                min_x=poi.easting - buffer,
                max_x=poi.easting + buffer,
                min_y=poi.northing - buffer,
                max_y=poi.northing + buffer,
                xs=self.nodes[&#34;easting&#34;],
                ys=self.nodes[&#34;northing&#34;],
            )
            node_subset = node_subset.merge(
                self.nodes, left_on=[&#34;x&#34;, &#34;y&#34;], right_on=[&#34;easting&#34;, &#34;northing&#34;]
            ).drop([&#34;x&#34;, &#34;y&#34;], axis=1)
            sub_source = self.edges.merge(
                node_subset, left_on=&#34;source&#34;, right_on=&#34;node_id&#34;
            )
            sub_target = self.edges.merge(
                node_subset, left_on=&#34;target&#34;, right_on=&#34;node_id&#34;
            )
            sub_edges = sub_source.append(sub_target).drop_duplicates(
                [&#34;source&#34;, &#34;target&#34;]
            )
            sub_graph = cugraph.Graph()
            sub_graph.from_cudf_edgelist(
                sub_edges,
                source=&#34;source&#34;,
                destination=&#34;target&#34;,
                edge_attr=self.weights,
            )

            pc_nodes = cudf.Series(poi.pc_node).isin(sub_graph.nodes()).sum()
            poi_node = sub_graph.nodes().isin([poi.node_id]).sum()

            # ensure all postcode nodes in + poi node
            if (poi_node) &amp; (pc_nodes == len(poi.pc_node)):
                return sub_graph
            buffer = (buffer + 100) * 2
            logger.debug(f&#34;{poi.Index=}: increasing {buffer=}&#34;)

    def get_shortest_dists(self, poi):
        &#34;&#34;&#34;
        Use `cugraph.sssp` to calculate shortest paths from POI to postcodes

        First subsets road graph, then finds shortest paths, ensuring all paths are
        routed that are known to be important to each POI. Saves to `hdf` to allow
        restarts.

        Parameters
        ----------
        poi : namedtuple
            Single POI created from `df.itertuples()`
        &#34;&#34;&#34;
        if self.use_buffers:
            self.graph = self.create_sub_graph(poi=poi)

        shortest_paths: cudf.DataFrame = cugraph.filter_unreachable(
            cugraph.sssp(self.graph, source=poi.node_id)
        )
        pc_dist = shortest_paths[shortest_paths.vertex.isin(self.postcode_ids)]

        self.idx += 1
        pc_dist[&#34;idx&#34;] = self.idx
        pc_dist.to_hdf(
            self.log_file,
            key=self.name,
            format=&#34;table&#34;,
            append=True,
            index=False,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ahah.routing.Routing.create_sub_graph"><code class="name flex">
<span>def <span class="ident">create_sub_graph</span></span>(<span>self, poi) ‑> cugraph.structure.graph_classes.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Create a subgraph of road nodes based on buffer distance</p>
<p>The subgraph is created using euclidean distance and
<code>cuspatial.points_in_spatial_window</code>. If buffers are not large enough to
include all nodes identified as important to that particular POI, it is
increased in size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>poi</code></strong> :&ensp;<code>namedtuple</code></dt>
<dd>Single POI created by <code>df.itertuples()</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cugraph.Graph:</code></dt>
<dd>Graph object that is a subset of all road nodes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_sub_graph(self, poi) -&gt; cugraph.Graph:
    &#34;&#34;&#34;
    Create a subgraph of road nodes based on buffer distance

    The subgraph is created using euclidean distance and
    `cuspatial.points_in_spatial_window`. If buffers are not large enough to
    include all nodes identified as important to that particular POI, it is
    increased in size.

    Parameters
    ----------
    poi : namedtuple
        Single POI created by `df.itertuples()`

    Returns
    -------
    cugraph.Graph:
        Graph object that is a subset of all road nodes
    &#34;&#34;&#34;
    # very small buffers do not work well
    buffer = poi.buffer if poi.buffer &gt;= 1000 else 1000
    while True:
        node_subset = cuspatial.points_in_spatial_window(
            min_x=poi.easting - buffer,
            max_x=poi.easting + buffer,
            min_y=poi.northing - buffer,
            max_y=poi.northing + buffer,
            xs=self.nodes[&#34;easting&#34;],
            ys=self.nodes[&#34;northing&#34;],
        )
        node_subset = node_subset.merge(
            self.nodes, left_on=[&#34;x&#34;, &#34;y&#34;], right_on=[&#34;easting&#34;, &#34;northing&#34;]
        ).drop([&#34;x&#34;, &#34;y&#34;], axis=1)
        sub_source = self.edges.merge(
            node_subset, left_on=&#34;source&#34;, right_on=&#34;node_id&#34;
        )
        sub_target = self.edges.merge(
            node_subset, left_on=&#34;target&#34;, right_on=&#34;node_id&#34;
        )
        sub_edges = sub_source.append(sub_target).drop_duplicates(
            [&#34;source&#34;, &#34;target&#34;]
        )
        sub_graph = cugraph.Graph()
        sub_graph.from_cudf_edgelist(
            sub_edges,
            source=&#34;source&#34;,
            destination=&#34;target&#34;,
            edge_attr=self.weights,
        )

        pc_nodes = cudf.Series(poi.pc_node).isin(sub_graph.nodes()).sum()
        poi_node = sub_graph.nodes().isin([poi.node_id]).sum()

        # ensure all postcode nodes in + poi node
        if (poi_node) &amp; (pc_nodes == len(poi.pc_node)):
            return sub_graph
        buffer = (buffer + 100) * 2
        logger.debug(f&#34;{poi.Index=}: increasing {buffer=}&#34;)</code></pre>
</details>
</dd>
<dt id="ahah.routing.Routing.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate and apply routing to each POI</p>
<p>This function primarily allows for the intermediate steps in routing to be
logged. This means that if the routing is stopped midway it can be restarted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self) -&gt; None:
    &#34;&#34;&#34;
    Iterate and apply routing to each POI

    This function primarily allows for the intermediate steps in routing to be
    logged. This means that if the routing is stopped midway it can be restarted.
    &#34;&#34;&#34;
    t1 = time.time()
    for poi in track(
        self.pois.iloc[self.idx :].itertuples(),
        description=f&#34;Processing {self.name}...&#34;,
        total=len(self.pois) - self.idx,
    ):
        self.get_shortest_dists(poi)
    t2 = time.time()
    tdiff = t2 - t1
    logger.debug(
        f&#34;Routing complete for {self.name} in {tdiff / 60:.2f} minutes,&#34;
        &#34; finding minimum distances.&#34;
    )

    t1 = time.time()
    self.distances = (
        dd.read_hdf(
            self.log_file,
            key=f&#34;{self.name}&#34;,
            columns=[&#34;vertex&#34;, &#34;distance&#34;],
        )
        .map_partitions(cudf.from_pandas)
        .groupby(&#34;vertex&#34;)
        .min()
        .compute()
    )
    t2 = time.time()
    tdiff = t2 - t1
    logger.debug(
        f&#34;Found minimum distances for {self.name} in {tdiff / 60:.2f} minutes.&#34;
    )
    self.log_file.unlink()</code></pre>
</details>
</dd>
<dt id="ahah.routing.Routing.get_shortest_dists"><code class="name flex">
<span>def <span class="ident">get_shortest_dists</span></span>(<span>self, poi)</span>
</code></dt>
<dd>
<div class="desc"><p>Use <code>cugraph.sssp</code> to calculate shortest paths from POI to postcodes</p>
<p>First subsets road graph, then finds shortest paths, ensuring all paths are
routed that are known to be important to each POI. Saves to <code>hdf</code> to allow
restarts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>poi</code></strong> :&ensp;<code>namedtuple</code></dt>
<dd>Single POI created from <code>df.itertuples()</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shortest_dists(self, poi):
    &#34;&#34;&#34;
    Use `cugraph.sssp` to calculate shortest paths from POI to postcodes

    First subsets road graph, then finds shortest paths, ensuring all paths are
    routed that are known to be important to each POI. Saves to `hdf` to allow
    restarts.

    Parameters
    ----------
    poi : namedtuple
        Single POI created from `df.itertuples()`
    &#34;&#34;&#34;
    if self.use_buffers:
        self.graph = self.create_sub_graph(poi=poi)

    shortest_paths: cudf.DataFrame = cugraph.filter_unreachable(
        cugraph.sssp(self.graph, source=poi.node_id)
    )
    pc_dist = shortest_paths[shortest_paths.vertex.isin(self.postcode_ids)]

    self.idx += 1
    pc_dist[&#34;idx&#34;] = self.idx
    pc_dist.to_hdf(
        self.log_file,
        key=self.name,
        format=&#34;table&#34;,
        append=True,
        index=False,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ahah" href="index.html">ahah</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ahah.routing.Routing" href="#ahah.routing.Routing">Routing</a></code></h4>
<ul class="">
<li><code><a title="ahah.routing.Routing.create_sub_graph" href="#ahah.routing.Routing.create_sub_graph">create_sub_graph</a></code></li>
<li><code><a title="ahah.routing.Routing.fit" href="#ahah.routing.Routing.fit">fit</a></code></li>
<li><code><a title="ahah.routing.Routing.get_shortest_dists" href="#ahah.routing.Routing.get_shortest_dists">get_shortest_dists</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>